@inproceedings{li2021model,
  title={Model-contrastive federated learning},
  author={Li, Qinbin and He, Bingsheng and Song, Dawn},
  booktitle={Proceedings of the IEEE/CVF conference on computer vision and pattern recognition},
  pages={10713--10722},
  year={2021}
}

@inproceedings{keller2020mp,
  title={MP-SPDZ: A versatile framework for multi-party computation},
  author={Keller, Marcel},
  booktitle={Proceedings of the 2020 ACM SIGSAC conference on computer and communications security},
  pages={1575--1590},
  year={2020}
}

@inproceedings{corrigan2017prio,
  title={Prio: Private, robust, and scalable computation of aggregate statistics},
  author={Corrigan-Gibbs, Henry and Boneh, Dan},
  booktitle={14th USENIX symposium on networked systems design and implementation (NSDI 17)},
  pages={259--282},
  year={2017}
}

@inproceedings{bonawitz2017practical,
  title={Practical secure aggregation for privacy-preserving machine learning},
  author={Bonawitz, Keith and Ivanov, Vladimir and Kreuter, Ben and Marcedone, Antonio and McMahan, H Brendan and Patel, Sarvar and Ramage, Daniel and Segal, Aaron and Seth, Karn},
  booktitle={proceedings of the 2017 ACM SIGSAC Conference on Computer and Communications Security},
  pages={1175--1191},
  year={2017}
}

@article{bonawitz2019towards,
  title={Towards federated learning at scale: System design},
  author={Bonawitz, Keith and Eichner, Hubert and Grieskamp, Wolfgang and Huba, Dzmitry and Ingerman, Alex and Ivanov, Vladimir and Kiddon, Chloe and Kone{\v{c}}n{\`y}, Jakub and Mazzocchi, Stefano and McMahan, Brendan and others},
  journal={Proceedings of machine learning and systems},
  volume={1},
  pages={374--388},
  year={2019}
}

@article{wu2020safa,
  title={SAFA: A semi-asynchronous protocol for fast federated learning with low overhead},
  author={Wu, Wentai and He, Ligang and Lin, Weiwei and Mao, Rui and Maple, Carsten and Jarvis, Stephen},
  journal={IEEE Transactions on Computers},
  volume={70},
  number={5},
  pages={655--668},
  year={2020},
  publisher={IEEE}
}

@inproceedings{naor2001efficient,
  title={Efficient oblivious transfer protocols.},
  author={Naor, Moni and Pinkas, Benny},
  booktitle={SODA},
  volume={1},
  pages={448--457},
  year={2001}
}

@incollection{goldreich2019play,
  title={How to play any mental game, or a completeness theorem for protocols with honest majority},
  author={Goldreich, Oded and Micali, Silvio and Wigderson, Avi},
  booktitle={Providing Sound Foundations for Cryptography: On the Work of Shafi Goldwasser and Silvio Micali},
  pages={307--328},
  year={2019}
}

@article{evans2018pragmatic,
  title={A pragmatic introduction to secure multi-party computation},
  author={Evans, David and Kolesnikov, Vladimir and Rosulek, Mike and others},
  journal={Foundations and Trends{\textregistered} in Privacy and Security},
  volume={2},
  number={2-3},
  pages={70--246},
  year={2018},
  publisher={Now Publishers, Inc.}
}

@misc{bates2024know,
      title={We Know I Know You Know; Choreographic Programming With Multicast and Multiply Located Values}, 
      author={Mako Bates and Joseph P. Near},
      year={2024},
      eprint={2403.05417},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@InBook{chor-lambda,
  author =       "Luís Cruz-Filipe and Eva Graversen and Lovro Lugović and Fabrizio Montesi and Marco Peressotti",
  editor =       "Helmut Seidl, Zhiming Liu, and Corina S. Pasareanu",
  title =        "Theoretical Aspects of Computing",
  subtitle =     "ICTAC 2022 – 19th International Colloquium",
  series =       "Lecture Notes in Computer Science",
  year =         "2022",
  address =      "Tbilisi, Georgia",
  publisher =    "Springer",
  doi =          "doi:10.1007/978-3-031-17715-6_15",
  url =          "https://arxiv.org/abs/2111.03701",
  volume =       "13572",
  chapter =      "Functional choreographic programming",
  pages =        "212–237",
  number =       "",
  type =         "",
  month =        "September",
  note =         "",
}

@article{choral,
author = {Giallorenzo, Saverio and Montesi, Fabrizio and Peressotti, Marco},
title = {Choral: Object-oriented Choreographic Programming},
year = {2024},
issue_date = {March 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {1},
issn = {0164-0925},
url = {https://doi.org/10.1145/3632398},
doi = {10.1145/3632398},
abstract = {Choreographies are coordination plans for concurrent and distributed systems, which define the roles of the involved participants and how they are supposed to work together. In the paradigm of choreographic programming, choreographies are programs that can be compiled into executable implementations.In this article, we present Choral, the first choreographic programming language based on mainstream abstractions. The key idea in Choral is a new notion of data type, which allows for expressing that data is distributed over different roles. We use this idea to reconstruct the paradigm of choreographic programming through object-oriented abstractions. Choreographies are classes, and instances of choreographies are objects with states and behaviours implemented collaboratively by roles.Choral comes with a compiler that, given a choreography, generates an implementation for each of its roles. These implementations are libraries in pure Java, whose types are under the control of the Choral programmer. Developers can then modularly compose these libraries in their programs, to participate correctly in choreographies. Choral is the first incarnation of choreographic programming offering such modularity, which finally connects more than a decade of research on the paradigm to practical software development.The integration of choreographic and object-oriented programming yields other powerful advantages, where the features of one paradigm benefit the other in ways that go beyond the sum of the parts. On the one hand, the high-level abstractions and static checks from the world of choreographies can be used to write concurrent and distributed object-oriented software more concisely and correctly. On the other hand, we obtain a much more expressive choreographic language from object-oriented abstractions than in previous work. This expressivity allows for writing more reusable and flexible choreographies. For example, object passing makes Choral the first higher-order choreographic programming language, whereby choreographies can be parameterised over other choreographies without any need for central coordination. We also extend method overloading to a new dimension: specialisation based on data location. Together with subtyping and generics, this allows Choral to elegantly support user-defined communication mechanisms and middleware.},
journal = {ACM Trans. Program. Lang. Syst.},
month = {jan},
articleno = {1},
numpages = {59},
keywords = {Choreographies, communication, higher-kinded types}
}

@misc{graversen2023polychor,
      title={Alice or Bob?: Process Polymorphism in Choreographies}, 
      author={Eva Graversen and Andrew K. Hirsch and Fabrizio Montesi},
      year={2023},
      eprint={2303.04678},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@misc{hirsch2021pirouette,
      title={Pirouette: Higher-Order Typed Functional Choreographies}, 
      author={Andrew K. Hirsch and Deepak Garg},
      year={2021},
      eprint={2111.03484},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@book{hunt1999,
  title={The Pragmatic Programmer: From Journeyman to Master},
  author={Hunt, A. and Thomas, D.},
  isbn={9780132119177},
  url={https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/},
  year={1999},
  publisher={Pearson Education}
}


@book{jongmans2022predicates,
title = "A Predicate Transformer for Choreographies (Full Version)",
abstract = "Abstract. Construction and analysis of distributed systems is difficult; choreographic programming is a deadlock-freedom-by-construction approach to simplify it. In this paper, we present a new theory of choreographic programming. It supports for the first time: construction of distributed systems that require decentralised decision making (i.e., if/ while-statements with multiparty conditions); analysis of distributed systems to provide not only deadlock freedom but also functional correctness (i.e., pre/postcondition reasoning). Both contributions are enabled by a single new technique, namely a predicate transformer for choreographies.",
author = "Sung-Shik Jongmans and {van den Bos}, Petra",
year = "2022",
language = "English",
series = "OUNL-CS (Technical Reports)",
publisher = "Open Universiteit Nederland",
number = "01",
}


@misc{chorus,
      title={Portable, Efficient, and Practical Library-Level Choreographic Programming}, 
      author={Shun Kashiwa and Gan Shen and Soroush Zare and Lindsey Kuper},
      year={2023},
      eprint={2311.11472},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}


@article{dprio2023,
author = {Keeler, Dana and Komlo, Chelsea and Lepert, Emily and Veitch, Shannon and He, Xi},
year = {2023},
month = {07},
pages = {375-390},
title = {DPrio: Efficient Differential Privacy with High Utility for Prio},
volume = {2023},
journal = {Proceedings on Privacy Enhancing Technologies},
doi = {10.56553/popets-2023-0086}
}

@inproceedings{noonanGDP,
author = {Noonan, Matt},
title = {Ghosts of departed proofs (functional pearl)},
year = {2018},
isbn = {9781450358354},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://kataskeue.com/gdp.pdf},
doi = {10.1145/3242744.3242755},
abstract = {Library authors often are faced with a design choice: should a function with preconditions be implemented as a partial function, or by returning a failure condition on incorrect use? Neither option is ideal. Partial functions lead to frustrating run-time errors. Failure conditions must be checked at the use-site, placing an unfair tax on the users who have ensured that the function's preconditions were correctly met.  In this paper, we introduce an API design concept called ``ghosts of departed proofs'' based on the following observation: sophisticated preconditions can be encoded in Haskell's type system with no run-time overhead, by using proofs that inhabit phantom type parameters attached to newtype wrappers. The user expresses correctness arguments by constructing proofs to inhabit these phantom types. Critically, this technique allows the library user to decide when and how to validate that the API's preconditions are met.  The ``ghosts of departed proofs'' approach to API design can achieve many of the benefits of dependent types and refinement types, yet only requires some minor and well-understood extensions to Haskell 2010. We demonstrate the utility of this approach through a series of case studies, showing how to enforce novel invariants for lists, maps, graphs, shared memory regions, and more.},
booktitle = {Proceedings of the 11th ACM SIGPLAN International Symposium on Haskell},
pages = {119–131},
numpages = {13},
keywords = {API design, formal methods, higher-rank types, software engineering},
location = {St. Louis, MO, USA},
series = {Haskell 2018}
}

@software{gdp_hackage,
  author = {Matt Noonan},
  title = {gdp: Reason about invariants and preconditions with ghosts of departed proofs.},
  url = {https://hackage.haskell.org/package/gdp-0.0.3.0},
  version = {0.0.3.0},
  date = {2019-11-13},
  year = {2019}
}

@INPROCEEDINGS{wysteria,
  author={Rastogi, Aseem and Hammer, Matthew A. and Hicks, Michael},
  booktitle={2014 IEEE Symposium on Security and Privacy}, 
  title={Wysteria: A Programming Language for Generic, Mixed-Mode Multiparty Computations}, 
  year={2014},
  volume={},
  number={},
  pages={655-670},
  keywords={Wires;Protocols;Cryptography;Semantics;Writing;Educational institutions;Standards;Secure multi-party computation;Functional language;Dependent type system},
  doi={10.1109/SP.2014.48}}


@article{haschor,
author = {Shen, Gan and Kashiwa, Shun and Kuper, Lindsey},
title = {HasChor: Functional Choreographic Programming for All (Functional Pearl)},
year = {2023},
issue_date = {August 2023},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {7},
number = {ICFP},
url = {https://doi.org/10.1145/3607849},
doi = {10.1145/3607849},
abstract = {Choreographic programming is an emerging paradigm for programming distributed systems. In choreographic programming, the programmer describes the behavior of the entire system as a single, unified program -- a choreography -- which is then compiled to individual programs that run on each node, via a compilation step called endpoint projection. We present a new model for functional choreographic programming where choreographies are expressed as computations in a monad. Our model supports cutting-edge choreographic programming features that enable modularity and code reuse: in particular, it supports higher-order choreographies, in which a choreography may be passed as an argument to another choreography, and location-polymorphic choreographies, in which a choreography can abstract over nodes. Our model is implemented in a Haskell library, HasChor, which lets programmers write choreographic programs while using the rich Haskell ecosystem at no cost, bringing choreographic programming within reach of everyday Haskellers. Moreover, thanks to Haskell's abstractions, the implementation of the HasChor library itself is concise and understandable, boiling down endpoint projection to its short and simple essence.},
journal = {Proc. ACM Program. Lang.},
month = {aug},
articleno = {207},
numpages = {25},
keywords = {Choreographic programming, freer monads}
}

@misc{haschor-repo,
author = {Shen, Gan},
month = {12},
title = {HasChor},
url = {https://github.com/gshen42/HasChor/tree/0896f9fdc395bf18c3f82121c0f99b4372ff620a},
year = {2023}
}

@article{Sweet_2023,
   title={Symphony: Expressive Secure Multiparty Computation with Coordination},
   volume={7},
   ISSN={2473-7321},
   url={http://dx.doi.org/10.22152/programming-journal.org/2023/7/14},
   DOI={10.22152/programming-journal.org/2023/7/14},
   number={3},
   journal={The Art, Science, and Engineering of Programming},
   publisher={Aspect-Oriented Software Association (AOSA)},
   author={Sweet, Ian and Darais, David and Heath, David and Harris, William and Estes, Ryan and Hicks, Michael},
   year={2023},
   month=feb }



@MISC {stackoverflow2021,
    TITLE = {Transitive 'Subset' class for type-level-sets},
    AUTHOR = {dfeuer (https://stackoverflow.com/users/1477667/dfeuer)},
    HOWPUBLISHED = {Stack Overflow},
    NOTE = {(version: 2021-11-11)},
    YEAR = {2021},
    URL = {https://stackoverflow.com/a/69921623/10135377}
}
